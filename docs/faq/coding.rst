Програмування
=============

.. contents:: Зміст
   :local:

Що таке "Arduino", "ESP-IDF" і ця ваша "бібліотека lilka"?
--------------------------------------------------------------

- **Arduino** - це фреймворк, яка дозволяє швидко і просто створювати програми для мікроконтролерів.

  Основна перевага Arduino - це стандартизований і простий інтерфейс програмування, який дозволяє швидко створювати програми для мікроконтролерів.
  Неважливо, чи ви пишете код для ESP32, чи для STM32, чи для ATmega: ви можете використовувати однаковий інтерфейс програмування, однакові функції та навіть однакові бібліотеки.

  Тобто Arduino - це своєрідна абстракція, яка дозволяє вам писати код для мікроконтролерів, не замислюючись про те, який саме мікроконтролер ви використовуєте.

- **ESP-IDF** - це офіційний фреймворк для програмування мікроконтролерів сімейства ESP32 від компанії Espressif.

  ESP-IDF - це більш низькорівневий фреймворк, який дозволяє вам працювати з ESP32 на більш низькому рівні, ніж Arduino.
  Код, написаний на ESP-IDF, може бути більш швидким і ефективним, ніж код, написаний на Arduino, але він також буде складнішим і працюватиме тільки на мікроконтролерах сімействі ESP32.

- **Бібліотека lilka** - це бібліотека, яку ми написали для роботи з ESP32-S3 на платформі Arduino.

  Це - спроба поєднати простоту Arduino з ефективністю ESP-IDF саме для написання програм для Лілки, а також надати додаткові функції, які допоможуть вам створити програми для Лілки швидше і простіше.

Але не лякайтесь: **ви можете одночасно використовувати і Arduino, і ESP-IDF, і бібліотеку lilka**!

Річ у тім, що бібліотека ``lilka`` написана на основі ESP32-Arduino, а ESP32-Arduino, в свою чергу, використовує ESP-IDF.
Це означає, що ви можете використовувати в своєму коді і функції ESP-IDF, і функції Arduino, і функції бібліотеки ``lilka``.

.. graphviz::

    digraph G {
        rankdir=LR;
        node[shape=box];
        "Ваш код" [style=filled, fillcolor="#aaffaa"];

        subgraph cluster_0 {
            style=filled;
            color=lightgrey;
            node [style=filled,color=white];
            "Бібліотека lilka";
            "ESP32 Arduino";
            "ESP-IDF";
        }

        "Ваш код" -> "Бібліотека lilka" [minlen=5];
        "Ваш код" -> "ESP32 Arduino";
        "Ваш код" -> "ESP-IDF";
        "Бібліотека lilka" -> "ESP32 Arduino" -> "ESP-IDF" [minlen=2];
        "Бібліотека lilka" -> "ESP-IDF";

        { rank=max; "Ваш код" }
    }

Що таке "паніка"?
-----------------

"Паніка" ("panic") - це загальна назва критичних ситуацій, які виникають, коли програма не може продовжувати свою роботу через критичну помилку або через потенційну можливість пошкодження даних.

Класична паніка - це дереференсія нульового вказівника:

.. code-block:: c

    int *p = NULL;
    *p = 42; // Паніка!

Проте паніка може бути викликана іншими причинами, такими як переповнення стеку, помилки вводу-виводу, помилки пам'яті, помилки в програмному коді, помилки в апаратурі, і так далі.

В більшості випадків при паніці ESP32 виводить в консоль не лише повідомлення про помилку, але і стек викликів, який привів до паніки.

Цей стек можна розкодувати, щоб побачити, які функції були викликані перед панікою і в якому порядку.

В KeiraOS для цього є "команда" ``decode_backtrace``, який використовує утиліту ``addr2line`` з комплекту ESP-IDF для розкодування стеку викликів. Ось як його використовувати:

.. code-block:: bash

    pio run -e v2 -t decode_backtrace -a '0x42013efa:0x3fcbbc10 0x4200894d:0x3fcbbcd0 0x4201962e:0x3fcbbd10 0x4201987b:0x3fcbbd30 0x4202724c:0x3fcbbd60'

Це виведе розкодовані функції та рядки, які викликалися перед панікою, від "найглибшої" до "найповерхневішої". Тобто перший рядок - це момент, де відбулася паніка.

Детальнішу інформацію про паніки можна знайти в `документації ESP-IDF <https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/api-guides/fatal-errors.html>`_.

Я отримую паніку ``Stack canary watchpoint triggered``
------------------------------------------------------

В ESP32 є спеціальний механізм, який дозволяє виявити переповнення стеку. Цей механізм називається "стекова канарка" (stack canary).
Він слідкує за переповненням стеку задачі.

Оскільки в FreeRTOS кожна задача при створенні отримує свою власну область стеку, яка визначається параметром ``stack_depth`` функцій ``xTaskCreate...``,
найчастіше ця помилка виникає через недостатньо велику область стеку вашої задачі. Ви можете збільшити розмір її стеку, визначивши більший розмір стеку при виклику ``xTaskCreate...``.

.. warning::

    Збільшення розміру стеку означає, що ваша програма буде використовувати більше пам'яті.

    Лілка використовує мікроконтролер ESP32-S3, який має всього декілька сотень кілобайт внутрішньої оперативної пам'яті (RAM), але крім неї вона має зовнішню оперативну пам'ять, яка називається PSRAM.

    Стек задачі зберігається у внутрішній RAM.

    Якщо вам потрібно зберігати великі обсяги даних в пам'яті, то можливо замість збільшення стеку вам краще варто використовувати динамічне виділення пам'яті в "купі",
    використовуючи функцію ``ps_malloc``, яка виділяє пам'ять у PSRAM (якої в Лілці аж 8 МБ).

    PSRAM дещо повільніша за внутрішню RAM, але вона дозволяє зберігати в десятки разів більше даних. В більшості випадків різниця в швидкості взагалі не буде помітною.

Я отримую паніку ``IllegalInstruction``
---------------------------------------

Ця помилка найчастіше трапляється, коли задача FreeRTOS, створена за допомогою одної з функцій ``xTaskCreate...``,
доходить до кінця (або робить ``return``) без виклику ``vTaskDelete(NULL)``.

Переконайтеся, що ваша задача завершується викликом ``vTaskDelete(NULL)``: іншими словами, викликайте ``vTaskDelete(NULL)`` замість ``return``.

Я отримую паніку ``Task watchdog got triggered``
------------------------------------------------

Ця помилка виникає, коли задача не викликає ``vTaskDelay`` або ``vTaskDelayUntil`` протягом певного часу.

В ESP32 є механізм "сторожового таймера" (watchdog timer), який слідкує за тим, щоб задачі виконувалися вчасно.
Якщо задача не викликає ``vTaskDelay`` або ``vTaskDelayUntil`` протягом певного часу (зазвичай 10 секунд), ви отримаєте помилку ``Task watchdog got triggered``.
Це робиться для того, щоб уникнути "зависання" задачі, яка не виконується.

Переконайтеся, що ваша задача час від часу викликає ``taskYIELD()`` чи ``vTaskDelay(1)``.

Якщо це неможливо - наприклад, якщо ви використовуєте сторонню бібліотеку, яка робить довгі і складні обчислення - ви можете збільшити таймаут сторожового таймера,
викликавши `esp_task_wdt_init <https://docs.espressif.com/projects/esp-idf/en/v4.4/esp32/api-reference/system/wdts.html#_CPPv417esp_task_wdt_init8uint32_tb>`_ з більшим значенням таймауту.
